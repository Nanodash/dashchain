// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'aggregated_trade.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

BinanceAggregatedTrade _$BinanceAggregatedTradeFromJson(
    Map<String, dynamic> json) {
  return _BinanceAggregatedTrade.fromJson(json);
}

/// @nodoc
class _$BinanceAggregatedTradeTearOff {
  const _$BinanceAggregatedTradeTearOff();

  _BinanceAggregatedTrade call(
      int a, String p, String q, int f, int l, int T, bool m, bool M) {
    return _BinanceAggregatedTrade(
      a,
      p,
      q,
      f,
      l,
      T,
      m,
      M,
    );
  }

  BinanceAggregatedTrade fromJson(Map<String, Object?> json) {
    return BinanceAggregatedTrade.fromJson(json);
  }
}

/// @nodoc
const $BinanceAggregatedTrade = _$BinanceAggregatedTradeTearOff();

/// @nodoc
mixin _$BinanceAggregatedTrade {
  /// Aggregate tradeId
  int get a => throw _privateConstructorUsedError;

  /// Price
  String get p => throw _privateConstructorUsedError;

  /// Quantity
  String get q => throw _privateConstructorUsedError;

  /// First tradeId
  int get f => throw _privateConstructorUsedError;

  /// Last tradeId
  int get l => throw _privateConstructorUsedError;

  /// Timestamp
  int get T => throw _privateConstructorUsedError;

  /// Was the buyer the maker?
  bool get m => throw _privateConstructorUsedError;

  /// Was the trade the best price match?
  bool get M => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $BinanceAggregatedTradeCopyWith<BinanceAggregatedTrade> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $BinanceAggregatedTradeCopyWith<$Res> {
  factory $BinanceAggregatedTradeCopyWith(BinanceAggregatedTrade value,
          $Res Function(BinanceAggregatedTrade) then) =
      _$BinanceAggregatedTradeCopyWithImpl<$Res>;
  $Res call({int a, String p, String q, int f, int l, int T, bool m, bool M});
}

/// @nodoc
class _$BinanceAggregatedTradeCopyWithImpl<$Res>
    implements $BinanceAggregatedTradeCopyWith<$Res> {
  _$BinanceAggregatedTradeCopyWithImpl(this._value, this._then);

  final BinanceAggregatedTrade _value;
  // ignore: unused_field
  final $Res Function(BinanceAggregatedTrade) _then;

  @override
  $Res call({
    Object? a = freezed,
    Object? p = freezed,
    Object? q = freezed,
    Object? f = freezed,
    Object? l = freezed,
    Object? T = freezed,
    Object? m = freezed,
    Object? M = freezed,
  }) {
    return _then(_value.copyWith(
      a: a == freezed
          ? _value.a
          : a // ignore: cast_nullable_to_non_nullable
              as int,
      p: p == freezed
          ? _value.p
          : p // ignore: cast_nullable_to_non_nullable
              as String,
      q: q == freezed
          ? _value.q
          : q // ignore: cast_nullable_to_non_nullable
              as String,
      f: f == freezed
          ? _value.f
          : f // ignore: cast_nullable_to_non_nullable
              as int,
      l: l == freezed
          ? _value.l
          : l // ignore: cast_nullable_to_non_nullable
              as int,
      T: T == freezed
          ? _value.T
          : T // ignore: cast_nullable_to_non_nullable
              as int,
      m: m == freezed
          ? _value.m
          : m // ignore: cast_nullable_to_non_nullable
              as bool,
      M: M == freezed
          ? _value.M
          : M // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc
abstract class _$BinanceAggregatedTradeCopyWith<$Res>
    implements $BinanceAggregatedTradeCopyWith<$Res> {
  factory _$BinanceAggregatedTradeCopyWith(_BinanceAggregatedTrade value,
          $Res Function(_BinanceAggregatedTrade) then) =
      __$BinanceAggregatedTradeCopyWithImpl<$Res>;
  @override
  $Res call({int a, String p, String q, int f, int l, int T, bool m, bool M});
}

/// @nodoc
class __$BinanceAggregatedTradeCopyWithImpl<$Res>
    extends _$BinanceAggregatedTradeCopyWithImpl<$Res>
    implements _$BinanceAggregatedTradeCopyWith<$Res> {
  __$BinanceAggregatedTradeCopyWithImpl(_BinanceAggregatedTrade _value,
      $Res Function(_BinanceAggregatedTrade) _then)
      : super(_value, (v) => _then(v as _BinanceAggregatedTrade));

  @override
  _BinanceAggregatedTrade get _value => super._value as _BinanceAggregatedTrade;

  @override
  $Res call({
    Object? a = freezed,
    Object? p = freezed,
    Object? q = freezed,
    Object? f = freezed,
    Object? l = freezed,
    Object? T = freezed,
    Object? m = freezed,
    Object? M = freezed,
  }) {
    return _then(_BinanceAggregatedTrade(
      a == freezed
          ? _value.a
          : a // ignore: cast_nullable_to_non_nullable
              as int,
      p == freezed
          ? _value.p
          : p // ignore: cast_nullable_to_non_nullable
              as String,
      q == freezed
          ? _value.q
          : q // ignore: cast_nullable_to_non_nullable
              as String,
      f == freezed
          ? _value.f
          : f // ignore: cast_nullable_to_non_nullable
              as int,
      l == freezed
          ? _value.l
          : l // ignore: cast_nullable_to_non_nullable
              as int,
      T == freezed
          ? _value.T
          : T // ignore: cast_nullable_to_non_nullable
              as int,
      m == freezed
          ? _value.m
          : m // ignore: cast_nullable_to_non_nullable
              as bool,
      M == freezed
          ? _value.M
          : M // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_BinanceAggregatedTrade implements _BinanceAggregatedTrade {
  _$_BinanceAggregatedTrade(
      this.a, this.p, this.q, this.f, this.l, this.T, this.m, this.M);

  factory _$_BinanceAggregatedTrade.fromJson(Map<String, dynamic> json) =>
      _$$_BinanceAggregatedTradeFromJson(json);

  @override

  /// Aggregate tradeId
  final int a;
  @override

  /// Price
  final String p;
  @override

  /// Quantity
  final String q;
  @override

  /// First tradeId
  final int f;
  @override

  /// Last tradeId
  final int l;
  @override

  /// Timestamp
  final int T;
  @override

  /// Was the buyer the maker?
  final bool m;
  @override

  /// Was the trade the best price match?
  final bool M;

  @override
  String toString() {
    return 'BinanceAggregatedTrade(a: $a, p: $p, q: $q, f: $f, l: $l, T: $T, m: $m, M: $M)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _BinanceAggregatedTrade &&
            const DeepCollectionEquality().equals(other.a, a) &&
            const DeepCollectionEquality().equals(other.p, p) &&
            const DeepCollectionEquality().equals(other.q, q) &&
            const DeepCollectionEquality().equals(other.f, f) &&
            const DeepCollectionEquality().equals(other.l, l) &&
            const DeepCollectionEquality().equals(other.T, T) &&
            const DeepCollectionEquality().equals(other.m, m) &&
            const DeepCollectionEquality().equals(other.M, M));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(a),
      const DeepCollectionEquality().hash(p),
      const DeepCollectionEquality().hash(q),
      const DeepCollectionEquality().hash(f),
      const DeepCollectionEquality().hash(l),
      const DeepCollectionEquality().hash(T),
      const DeepCollectionEquality().hash(m),
      const DeepCollectionEquality().hash(M));

  @JsonKey(ignore: true)
  @override
  _$BinanceAggregatedTradeCopyWith<_BinanceAggregatedTrade> get copyWith =>
      __$BinanceAggregatedTradeCopyWithImpl<_BinanceAggregatedTrade>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_BinanceAggregatedTradeToJson(this);
  }
}

abstract class _BinanceAggregatedTrade implements BinanceAggregatedTrade {
  factory _BinanceAggregatedTrade(
          int a, String p, String q, int f, int l, int T, bool m, bool M) =
      _$_BinanceAggregatedTrade;

  factory _BinanceAggregatedTrade.fromJson(Map<String, dynamic> json) =
      _$_BinanceAggregatedTrade.fromJson;

  @override

  /// Aggregate tradeId
  int get a;
  @override

  /// Price
  String get p;
  @override

  /// Quantity
  String get q;
  @override

  /// First tradeId
  int get f;
  @override

  /// Last tradeId
  int get l;
  @override

  /// Timestamp
  int get T;
  @override

  /// Was the buyer the maker?
  bool get m;
  @override

  /// Was the trade the best price match?
  bool get M;
  @override
  @JsonKey(ignore: true)
  _$BinanceAggregatedTradeCopyWith<_BinanceAggregatedTrade> get copyWith =>
      throw _privateConstructorUsedError;
}
